# Interview List

간단히 개념들을 정리해보며 머리 속에 넣자~

<br>

- [언어(Java, C++ ... )](<https://github.com/kim6394/Dev_BasicKnowledge/blob/master/Interview/README.md#언어>)
- [운영체제](<https://github.com/kim6394/Dev_BasicKnowledge/blob/master/Interview/README.md#운영체제>)
- [데이터베이스](<https://github.com/kim6394/Dev_BasicKnowledge/blob/master/Interview/README.md#데이터베이스>)
- [네트워크](https://github.com/kim6394/Dev_BasicKnowledge/blob/master/Interview/README.md#네트워크)
- [스프링](https://github.com/kim6394/Dev_BasicKnowledge/blob/master/Interview/README.md#스프링)

<br>

<br>

### 언어(C++ 등..)

---

#### Vector와 ArrayList의 차이는?

> Vector : 동기식. 한 스레드가 벡터 작업 중이면 다른 스레드가 벡터 보유 불가능
>
> ArrayList : 비동기식. 여러 스레드가 arraylist에서 동시 작업이 가능

<br>

#### Serialization이란?

> 직렬화. 객체의 상태 혹은 데이터 구조를 기록할 수 있는 포맷으로 변환해줌
>
> 나중에 재구성 할 수 있게 자바 객체를 JSON으로 변환해주거나 JSON을 자바 객체로 변환해주는 라이브러리

<br>

#### Hash란?

> 데이터 삽입 및 삭제 시, 기존 데이터를 밀어내거나 채우지 않고 데이터와 연관된 고유한 숫자를 생성해 인덱스로 사용하는 방법
>
> 검색 속도가 매우 빠르다

<br>

#### Call by Value vs Call by Reference

> 값에 의한 호출 : 값을 복사해서 새로운 함수로 넘기는 호출 방식. 원본 값 변경X
>
> 참조에 의한 호출 :  주소 값을 인자로 전달하는 호출 방식. 원본 값 변경O

<br>

#### 배열과 연결리스트 차이는?

> 배열은 인덱스를 가짐. 원하는 데이터를 한번에 접근하기 때문에 접근 속도 빠름.
>
> 크기 변경이 불가능하며, 데이터 삽입 및 삭제 시 그 위치의 다음 위치부터 모든 데이터 위치를 변경해야 되는 단점 존재
>
> 연결리스트는 인덱스 대신에 현재 위치의 이전/다음 위치를 기억함.
>
> 크기는 가변적. 인덱스 접근이 아니기 때문에 연결되어 있는 링크를 쭉 따라가야 접근이 가능함. (따라서 배열보다 속도 느림)
>
> 데이터 삽입 및 삭제는 논리적 주소만 바꿔주면 되기 때문에 매우 용이함
>
> - 데이터의 양이 많고 삽입/삭제가 없음. 데이터 검색을 많이 해야할 때 → Array
> - 데이터의 양이 적고 삽입/삭제 빈번함 → LinkedList

<br>

#### 스레드는 어떤 방식으로 생성하나요? 장단점도 말해주세요

> 생성방법 : Runnable(인터페이스)로 선언되어 있는 클래스 or Thread 클래스를 상속받아서 run() 메소드를 구현해주면 됨
>
> 장점 : 빠른 프로세스 생성, 메모리를 적게 사용 가능, 정보 공유가 쉬움
>
> 단점 : 데드락에 빠질 위험이 존재

<br>

#### C++ 실행 과정

> 전처리 : #define, #include 지시자 해석
>
> 컴파일 : 고급 언어 소스 프로그램 입력 받고, 어셈블리 파일 만듬
>
> 어셈블 : 어셈블리 파일을 오브젝트 파일로 만듬
>
> 링크 : 오브젝트 파일을 엮어 실행파일을 만들고 라이브러리 함수 연결
>
> 실행

<br>

#### 메모리, 성능을 개선하기 위해 생각나는 방법은?

> static을 사용해 선언한다.
>
> 인스턴스 변수에 접근할 일이 없으면, static 메소드를 선언하여 호출하자
>
> 모든 객체가 서로 공유할 수 있기 때문에 메모리가 절약되고 연속적으로 그 값의 흐름을 이어갈 수 있는 장점이 존재

<br>

#### 클래스와 구조체의 차이는?

> 구조체는 하나의 구조로 묶일 수 있는 변수들의 집합이다.
>
> 클래스는 변수뿐만 아니라, 메소드도 포함시킬 수 있음
>
> (물론 함수 포인터를 이용해 구조체도 클래스처럼 만들어 낼 수도 있다.)

<br>

#### 포인터를 이해하기 쉽도록 설명해주세요

> 포인터는 메모리 주소를 저장하는 변수임
>
> 주소를 지칭하고 있는 곳인데, 예를 들면 엘리베이터에서 포인터는 해당 층을 표시하는 버튼이라고 할 수 있음. 10층을 누르면 10층으로 이동하듯, 해당 위치를 가리키고 있는 변수!
>
> 포인터를 사용할 때 주의할 점은, 어떤 주소를 가리키고 있어야만 사용이 가능함

<br>

<br>

<br>

### 운영체제

---

#### 프로세스와 스레드 차이

> 프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다.
>
> 프로세스마다 최소 하나의 스레드를 보유하고 있으며, 각각 별도의 주소공간을 독립적으로 할당받는다. (code, data, heap, stack)
>
> 스레드는 이중에 stack만 따로 할당받고 나머지 영역은 스레드끼리 서로 공유한다.
>
> ##### 요약
>
> **프로세스** :  자신만의 고유 공간과 자원을 할당받아 사용
>
> **스레드** : 다른 스레드와 공간과 자원을 공유하면서 사용

<br>

#### 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?

> 프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능함
>
> 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소함
>
> 대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제 해결을 위해 '동기화'에 신경써야 한다.

<br>

#### 교착상태(DeadLock)가 무엇이며, 4가지 조건은?

> 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말한다.
>
> 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생하는 문제임
>
> 교착상태의 4가지 조건은 아래와 같다.
>
> - 상호배제 : 프로세스들이 필요로 하는 자원에 대해 배타적 통제권을 요구함
> - 점유대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원 기다림
> - 비선점 : 프로세스가 어떤 자원의 사용을 끝날 때까지 그 자원을 뺏을 수 없음
> - 순환대기 : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있음
>
> 이 4가지 조건 중 하나라도 만족하지 않으면 교착상태는 발생하지 않음
>
> (순환대기는 점유대기와 비선점을 모두 만족해야만 성립합. 따라서 4가지가 서로 독립적이진 않음)

<br>

#### 교착상태 해결 방법 4가지

> - 예방
> - 회피
> - 무시
> - 발견

<br>

#### 메모리 계층 (상-하층 순)

> |  레지스터  |
> | :--------: |
> |    캐시    |
> |   메모리   |
> | 하드디스크 |

<br>

#### 메모리 할당 알고리즘 First fit, Next fit, Best fit 결과

> - First fit : 메모리의 처음부터 검사해서 크기가 충분한 첫번째 메모리에 할당
> - Next fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾음
> - Best fit : 모든 메모리 공간을 검사해서 내부 단편화를 최소화하는 공간에 할당

<br>

#### 페이지 교체 알고리즘에 따른 페이지 폴트 방식

> OPT : 최적 교체. 앞으로 가장 오랫동안 사용하지 않을 페이지 교체 (실현 가능성 희박)
>
> FIFO : 메모리가 할당된 순서대로 페이지를 교체
>
> LRU : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체
>
> LFU : 사용 빈도가 가장 적은 페이지를 교체
>
> NUR : 최근에 사용하지 않은 페이지를 교체

<br>

#### 외부 단편화와 내부 단편화란?

> 외부 단편화 : 작업보다 많은 공간이 있더라도 실제로 그 작업을 받아들일 수 없는 경우 (메모리 배치에 따라 발생하는 문제)
>
> 내부 단편화 : 작업에 필요한 공간보다 많은 공간을 할당받음으로써 발생하는 내부의 사용 불가능한 공간

<br>

#### 가상 메모리란?

> 메모리에 로드된, 실행중인 프로세스가 메모리가 아닌 가상의 공간을 참조해 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수 있게 해주는 기법

<br>

#### 페이징과 세그먼테이션이란?

> ##### 페이징
>
> 페이지 단위의 논리-물리 주소 관리 기법.
> 논리 주소 공간이 하나의 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 기법
> 논리 주소 공간과 물리 주소 공간을 분리해야함(주소의 동적 재배치 허용), 변환을 위한 MMU 필요
>
> 특징 : 외부 단편화를 없앨 수 있음. 페이지가 클수록 내부 단편화도 커짐
>
> ##### 세그먼테이션
>
> 사용자/프로그래머 관점의 메모리 관리 기법. 페이징 기법은 같은 크기의 페이지를 갖는 것 과는 다르게 논리적 단위(세그먼트)로 나누므로 미리 분할하는 것이 아니고 메모리 사용할 시점에 할당됨

<br>

#### 뮤텍스, 세마포어가 뭔지, 차이점은?

> ##### 세마포어
>
> 운영체제에서 공유 자원에 대한 접속을 제어하기 위해 사용되는 신호
> 공유자원에 접근할 수 있는 최대 허용치만큼만 동시에 사용자 접근 가능
> 스레드들은 리소스 접근 요청을 할 수 있고, 세마포어는 카운트가 하나씩 줄어들게 되며 리소스가 모두 사용중인 경우(카운트=0) 다음 작업은 대기를 하게 된다
>
> ##### 뮤텍스
>
> 상호배제, 제어되는 섹션에 하나의 스레드만 허용하기 때문에, 해당 섹션에 접근하려는 다른 스레드들을 강제적으로 막음으로써 첫 번째 스레드가 해당 섹션을 빠져나올 때까지 기다리는 것
> (대기열(큐) 구조라고 생각하면 됨)
>
> ##### 차이점
>
> - 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없음
> - 세마포어는 소유 불가능하지만, 뮤택스는 소유가 가능함
> - 동기화의 개수가 다름

<br>

#### Context Switching이란?

> 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업
>
> 한 프로세스의 문맥은 그 프로세스의 PCB에 기록됨

<br>

#### 사용자 수준 스레드 vs 커널 수준 스레드 차이는?

> ##### 사용자 수준 스레드
>
> 장점 : context switching이 없어서 커널 스레드보다 오버헤드가 적음 (스레드 전환 시 커널 스케줄러 호출할 필요가 없기 때문)
>
> 단점 : 프로세스 내의 한 스레드가 커널로 진입하는 순간, 나머지 스레드들도 전부 정지됨 (커널이 스레드의 존재를 알지 못하기 때문에)
>
> ##### 커널 수준 스레드
>
> 장점 : 사용자 수준 스레드보다 효율적임. 커널 스레드를 쓰면 멀티프로세서를 활용할 수 있기 때문이다. 사용자 스레드는 CPU가 아무리 많아도 커널 모드의 스케줄이 되지 않으므로, 각 CPU에 효율적으로 스레드 배당할 수가 없음
>
> 단점 : context switching이 발생함. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 많이 돌아다닐 수록 성능이 떨어지게 된다.

<br>

#### 가상메모리란?

> 프로세스에서 사용하는 메모리 주소와 실제 물리적 메모리 주소는 다를 수 있음
>
> 따라서 메모리 = 실제 + 가상 메모리라고 생각하면 안됨
>
> 메모리가 부족해서 가상메모리를 사용하는 건 맞지만, 가상메모리를 쓴다고 실제 메모리처럼 사용하는 것은 아님
>
> 실제 메모리 안에 공간이 부족하면, **현재 사용하고 있지 않은 데이터를 빼내어 가상 메모리에 저장해두고, 실제 메모리에선 처리만 하게 하는 것이 가상 메모리의 역할**이다.
>
> 즉, 실제 메모리에 놀고 있는 공간이 없게 계속 일을 시키는 것. 이를 도와주는 것이 '가상 메모리'

<br>

#### fork()와 vfork()의 차이점은?

> fork()는 부모 프로세스의 메모리를 복사해서 사용
>
> vfork()는 부모 프로세스와의 메모리를 공유함. 복사하지 않기 때문에 fork()보다 생성 속도 빠름.
> 하지만 자원을 공유하기 때문에 자원에 대한 race condition이 발생하지 않도록 하기 위해 부모 프로세스는 자식 프로세스가 exit하거나 execute가 호출되기 전까지 block된다

<br>

#### Race Condition이란?

> 두 개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓸 때, 공용 데이터에 대한 접근이 순서에 따라 실행 결과가 달라지는 상황
>
> Race Condition이 발생하게 되면, 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없음. 따라서 이러한 상황은 피해야 하며 상호배제나 임계구역으로 해결이 가능하다.

<br>

#### 리눅스에서 시스템 콜과 서브루틴의 차이는?

> 우선 커널을 확인하자
>
> <img src="https://s24255.pcdn.co/wp-content/uploads/2012/07/Kernel.png">
>
> 커널은 하드웨어를 둘러싸고 있음
>
> 즉, 커널은 하드웨어를 제어하기 위한 일종의 API와 같음
>
> 서브루틴(SubRoutine)은 우리가 프로그래밍할 때 사용하는 대부분의 API를 얘기하는 것
>
> ```
> stdio.h에 있는 printf나 scanf
> string.h에 있는 strcmp나 strcpy
> ```
>
> ##### 서브루틴과 시스템 콜의 차이는?
>
> 서브루틴이 시스템 콜을 호출하고, 시스템 콜이 수행한 결과를 서브루틴에 보냄
>
> 시스템 콜 호출 시, 커널이 호출되고 커널이 수행한 임의의 결과 데이터를 다시 시스템 콜로 보냄
>
> 즉, 진행 방식은 아래와 같다.
>
> ```
> 서브루틴이 시스템 콜 호출 → 시스템 콜은 커널 호출 → 커널은 자신의 역할을 수행하고 (하드웨어를 제어함) 나온 결과 데이터를 시스템 콜에게 보냄 → 시스템 콜이 다시 서브루틴에게 보냄
> ```
>
> 실무로 사용할 때 둘의 큰 차이는 없음(api를 호출해서 사용하는 것은 동일)

<br>

#### IOCP를 설명하시오

> IOCP는 어떤 I/O 핸들에 대해, 블록 되지 않게 비동기 작업을 하면서 프로그램 대기시간을 줄이는 목적으로 사용된다.
>
> 동기화 Object 세마포어의 특성과, 큐를 가진 커널 Object다. 대부분 멀티 스레드 상에서 사용되고, 큐는 자체적으로 운영하는 특징 때문에 스레드 풀링에 적합함
>
> 동기화와 동시에 큐를 통한 데이터 전달 IOCP는, 스레드 풀링을 위한 것이라고 할 수 있음
>
> ##### POOLING이란?
>
> 여러 스레드를 생성하여 대기시키고, 필요할 때 가져다가 사용한 뒤에 다시 반납하는 과정
> (스레드의 생성과 파괴는 상당히 큰 오버헤드가 존재하기 때문에 이 과정을 이용한다)
>
> IOCP의 장점은 사용자가 설정한 버퍼만 사용하기 때문에 더 효율적으로 작동시킬 수 있음.
> (기존에는 OS버퍼, 사용자 버퍼로 따로 분리해서 운영했음)
>
> 커널 레벨에서는 모든 I/O를 비동기로 처리하기 때문에 효율적인 순서에 따라 접근할 수 있음

<br>

<br>

### 데이터베이스

------

#### 오라클 시퀀스(Oracle Sequence)

> UNIQUE한 값을 생성해주는 오라클 객체
>
> 시퀀스를 생성하면 PK와 같이 순차적으로 증가하는 컬럼을 자동 생성할수 있다.
>
> ```
> CREATE SEQUENCE 시퀀스이름
> 	START WITH n
> 	INCREMENT BY n ...
> ```

<br>

#### DBMS란?

> 데이터베이스 관리 시스템
>
> 다수의 사용자가 데이터베이스 내의 데이터를 접근할 수 있도록 설계된 시스템

<br>

#### DBMS의 기능은?

> - 정의 기능(DDL: Data Definition Language)
    >

- 데이터베이스가 어떤 용도이며 어떤 식으로 이용될것이라는 것에 대한 정의가 필요함

>     - CREATE, ALTER, DROP, RENAME
>
> - 조작 기능(DML: Data Manipulation Language)
    >

- 데이터베이스를 만들었을 때 그 정보를 수정하거나 삭제 추가 검색 할 수 있어야함

>     - SELECT, INSERT, UPDATE, DELETE
>
> - 제어 기능(DCL: Data Control Language)
    >

- 데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회수하는 명령

>     - GRANT REVOKE

<br>

#### UML이란?

> 프로그램 설계를 표현하기 위해 사용하는 그림으로 된 표기법
>
> 이해하기 힘든 복잡한 시스템을 의사소통하기 위해 만듬

<br>

#### DB에서 View는 무엇인가? 가상 테이블이란?

> 허용된 데이터를 제한적으로 보여주기 위한 것
>
> 하나 이상의 테이블에서 유도된 가상 테이블이다.
>
> - 사용자가 view에 접근했을 때 해당하는 데이터를 원본에서 가져온다.
>
> view에 나타나지 않은 데이터를 간편히 보호할 수 있는 장점 존재

<br>

#### 정규화란?

> 중복을 최대한 줄여 데이터를 구조화하고, 불필요한 데이터를 제거해 데이터를 논리적으로 저장하는 것
>
> 이상현상이 일어나지 않도록 정규화 시킨다!

<br>

#### 이상현상이란?

> 릴레이션에서 일부 속성들의 종속으로 인해 데이터 중복이 발생하는 것 (insert, update, delete)

<br>

#### 데이터베이스를 설계할 때 가장 중요한 것이 무엇이라고 생각하나요?

> 무결성을 보장해야 합니다.
>
> ##### 무결성 보장 방법은?
>
> 데이터를 조작하는 프로그램 내에서 데이터 생성, 수정, 삭제 시 무결성 조건을 검증한다.
>
> 트리거 이벤트 시 저장 SQL을 실행하고 무결성 조건을 실행한다.
>
> DB제약조건 기능을 선언한다.

<br>

#### 데이터베이스 무결성이란?

> 테이블에 있는 모든 행들이 유일한 식별자를 가질 것을 요구함 (같은 값 X)
>
> 외래키 값은 NULL이거나 참조 테이블의 PK값이어야 함
>
> 한 컬럼에 대해 NULL 허용 여부와 자료형, 규칙으로 타당한 데이터 값 지정

<br>

#### 트리거란?

> 자동으로 실행되도록 정의된 저장 프로시저
>
> (insert, update, delete문에 대한 응답을 자동으로 호출한다.)
>
> ##### 사용하는 이유는?
>
> 업무 규칙 보장, 업무 처리 자동화, 데이터 무결성 강화

<br>

#### 오라클과 MySQL의 차이는?

> 일단 Oracle이 MySQL보다 훨~씬 좋음
>
> 오라클 : 대규모 트랜잭션 로드를 처리하고, 성능 최적화를 위해 여러 서버에 대용량 DB를 분산함
>
> MySQL : 단일 데이터베이스로 제한되어있고, 대용량 데이터베이스로는 부적합. 작은 프로젝트에서 적용시키기 용이하며 이전 상태를 복원하는데 commit과 rollback만 존재

<br>

#### Commit과 Rollback이란?

> Commit : 하나의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산
>
> Rollback : 하나의 트랜잭션 처리가 비정상적으로 종료되어 DB의 일관성을 깨뜨렸을 때, 모든 연산을 취소시키는 연산

<br>

#### JDBC와 ODBC의 차이는?

> - JDBC
    > 자바에서 DB에 접근하여 데이터를 조회, 삽입, 수정, 삭제 가능
    > DBMS 종류에 따라 맞는 jdbc를 설치해야함
> - ODBC
    > 응용 프로그램에서 DB 접근을 위한 표준 개방형 응용 프로그램 인터페이스
    > MS사에서 만들었으며, Excel/Text 등 여러 종류의 데이터에 접근할 수 있음

<br>

#### 데이터 베이스에서 인덱스(색인)이란 무엇인가요

> - 책으로 비유하자면 목차로 비유할 수 있다.
> - DBMS에서 저장 성능을 희생하여 데이터 읽기 속도를 높이는 기능
> - 데이터가 정렬되어 들어간다
> - 양이 많은 테이블에서 일부 데이터만 불러 왔을 때, 이를 풀 스캔 시 처리 성능 떨어짐
> - 종류
    >

- B+-Tree 인덱스 : 원래의 값을 이용하여 인덱싱

>     - Hash 인덱스 : 칼럼 값으로 해시 값 게산하여 인덱싱, 메모리 기반 DB에서 많이 사용
>     - B>Hash
> - 생성시 고려해야 할 점
    >

- 테이블 전체 로우 수 15%이하 데이터 조회시 생성

>     - 테이블 건수가 적으면 인덱스 생성 하지 않음, 풀 스캔이 빠름
>     - 자주 쓰는 컬럼을 앞으로 지정
>     - DML시 인덱스에도 수정 작업이 동시에 발생하므로 DML이 많은 테이블은 인덱스 생성 하지 않음


<br>

<br>

## 스프링

<br>

#### Dispatcher-Servlet

> 서블릿 컨테이너에서 HTTP 프로토콜을 통해 들어오는 모든 요청을 제일 앞에서 처리해주는 프론트 컨트롤러를 말함
>
> 따라서 서버가 받기 전에, 공통처리 작업을 디스패처 서블릿이 처리해주고 적절한 세부 컨트롤러로 작업을 위임해줍니다.
>
> 디스패처 서블릿이 처리하는 url 패턴을 지정해줘야 하는데, 일반적으로는 .mvc와 같은 패턴으로 처리하라고 미리 지정해줍니다.
>
>
> 디스패처 서블릿으로 인해 web.xml이 가진 역할이 상당히 축소되었습니다. 기존에는 모든 서블릿을 url 매핑 활용을 위해 모두 web.xml에 등록해 주었지만, 디스패처 서블릿은 그 전에 모든 요청을 핸들링해주면서 작업을 편리하게 할 수 있도록 도와줍니다. 또한 이 서블릿을 통해 MVC를 사용할 수 있기 때문에 웹 개발 시 큰 장점을 가져다 줍니다.

<br>

#### DI(Dependency Injection)

> 스프링 컨테이너가 지원하는 핵심 개념 중 하나로, 설정 파일을 통해 객체간의 의존관계를 설정하는 역할을 합니다.
>
> 각 클래스 사이에 필요로 하는 의존관계를 Bean 설정 정보 바탕으로 컨테이너가 자동으로 연결합니다.
>
> 객체는 직접 의존하고 있는 객체를 생성하거나 검색할 필요가 없으므로 코드 관리가 쉬워지는 장점이 있습니다.

<br>

#### AOP(Aspect Oriented Programming)

> 공통의 관심 사항을 적용해서 발생하는 의존 관계의 복잡성과 코드 중복을 해소해줍니다.
>
> 각 클래스에서 공통 관심 사항을 구현한 모듈에 대한 의존관계를 갖기 보단, Aspect를 이용해 핵심 로직을 구현한 각 클래스에 공통 기능을 적용합니다.
>
> 간단한 설정만으로도 공통 기능을 여러 클래스에 적용할 수 있는 장점이 있으며 핵심 로직 코드를 수정하지 않고도 웹 애플리케이션의 보안, 로깅, 트랜잭션과 같은 공통 관심 사항을 AOP를 이용해 간단하게 적용할 수 있습니다.

<br>

#### AOP 용어

> Advice : 언제 공통 관심기능을 핵심 로직에 적용할지 정의
>
> Joinpoint : Advice를 적용이 가능한 지점을 의미 (before, after 등등)
>
> Pointcut : Joinpoint의 부분집합으로, 실제로 Advice가 적용되는 Joinpoint를 나타냄
>
> Weaving : Advice를 핵심 로직코드에 적용하는 것
>
> Aspect : 여러 객체에 공통으로 적용되는 공통 관심 사항을 말함. 트랜잭션이나 보안 등이 Aspect의 좋은 예

<br>

#### DAO(Data Access Object)

> DB에 데이터를 조회하거나 조작하는 기능들을 전담합니다.
>
> Mybatis를 이용할 때는, mapper.xml에 쿼리문을 작성하고 이를 mapper 클래스에서 받아와 DAO에게 넘겨주는 식으로 구현합니다.

<br>

#### Annotation

> 소스코드에 @어노테이션의 형태로 표현하며 클래스, 필드, 메소드의 선언부에 적용할 수 있는 특정기능이 부여된 표현법을 말합니다.
>
> 애플리케이션 규모가 커질수록, xml 환경설정이 매우 복잡해지는데 이러한 어려움을 개선시키기 위해 자바 파일에 어노테이션을 적용해서 개발자가 설정 파일 작업을 할 때 발생시키는 오류를 최소화해주는 역할을 합니다.
>
> 어노테이션 사용으로 소스 코드에 메타데이터를 보관할 수 있고, 컴파일 타임의 체크뿐 아니라 어노테이션 API를 사용해 코드 가독성도 높여줍니다.

- @Controller : dispatcher-servlet.xml에서 bean 태그로 정의하는 것과 같음.
- @RequestMapping : 특정 메소드에서 요청되는 URL과 매칭시키는 어노테이션
- @Autowired : 자동으로 의존성 주입하기 위한 어노테이션
- @Service : 비즈니스 로직 처리하는 서비스 클래스에 등록
- @Repository : DAO에 등록

<br>

#### Spring JDBC

> 데이터베이스 테이블과, 자바 객체 사이의 단순한 매핑을 간단한 설정을 통해 처리하는 것
>
> 기존의 JDBC에서는 구현하고 싶은 로직마다 필요한 SQL문이 모두 달랐고, 이에 필요한 Connection, PrepareStatement, ResultSet 등을 생성하고 Exception 처리도 모두 해야하는 번거러움이 존재했습니다.
>
> Spring에서는 JDBC와 ORM 프레임워크를 직접 지원하기 때문에 따로 작성하지 않아도 모두 다 처리해주는 장점이 있습니다.

<br>

#### MyBatis

> 객체, 데이터베이스, Mapper 자체를 독립적으로 작성하고, DTO에 해당하는 부분과 SQL 실행결과를 매핑해서 사용할 수 있도록 지원함
>
> 기존에는 DAO에 모두 SQL문이 자바 소스상에 위치했으나, MyBatis를 통해 SQL은 XML 설정 파일로 관리합니다.
>
> 설정파일로 분리하면, 수정할 때 설정파일만 건드리면 되므로 유지보수에 매우 좋습니다. 또한 매개변수나 리턴 타입으로 매핑되는 모든 DTO에 관련된 부분도 모두 설정파일에서 작업할 수 있는 장점이 있습니다.

<br>

<br>

<br>
