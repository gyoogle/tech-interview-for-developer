# Interview List

간단히 개념들을 정리해보며 머리 속에 넣자~

<br>

- [언어(Java, C++ ... )](<https://github.com/kim6394/Dev_BasicKnowledge/blob/master/Interview/README.md#언어>)
- [운영체제](<https://github.com/kim6394/Dev_BasicKnowledge/blob/master/Interview/README.md#운영체제>)
- [데이터베이스](<https://github.com/kim6394/Dev_BasicKnowledge/blob/master/Interview/README.md#데이터베이스>)
- [네트워크](https://github.com/kim6394/Dev_BasicKnowledge/blob/master/Interview/README.md#네트워크)
- [스프링](https://github.com/kim6394/Dev_BasicKnowledge/blob/master/Interview/README.md#스프링)

<br>

<br>

### 언어(Java, C++ 등..)

---

#### 가비지 컬렉션이란?

> 정리되지 않은 메모리, 유효하지 않은 메모리 주소인 가비지를 정리해주는 프로그램
>
> Heap 메모리를 재활용 하기위해 참조되지 않는 객체들을 해제시켜 가용한 공간을 만드는 작업
>
> 프로그래머가 직접 메모리를 정리하지 않아도 되어 개발 속도가 대폭 향상된다.
>
> 메모리를 언제 되찾을 지 결정하기 위한 오버헤드 발생 문제점 존재

<br>

#### Vector와 ArrayList의 차이는?

> Vector : 동기식. 한 스레드가 벡터 작업 중이면 다른 스레드가 벡터 보유 불가능
>
> ArrayList : 비동기식. 여러 스레드가 arraylist에서 동시 작업이 가능

<br>

#### String과 StringBuffer의 차이는?

> String : 불변. 문자를 수정하려면 지우고 다시 생성해야함 (new) → 문자열 연산이 많으면 기능 떨어짐
>
> StringBuffer : 가변. 한번 만들고 필요할 때 크기를 변경하여 문자를 변경함 (append()와 같이)
>
> StringBuilder : 동기화 지원X. 멀티스레드 환경에 부적합 → 싱글 스레드에서 StringBuffer보다 좋음

<br>

#### Serialization이란?

> 직렬화. 객체의 상태 혹은 데이터 구조를 기록할 수 있는 포맷으로 변환해줌
>
> 나중에 재구성 할 수 있게 자바 객체를 JSON으로 변환해주거나 JSON을 자바 객체로 변환해주는 라이브러리

<br>

#### Java의 메모리 영역은?

> - 메소드 / 스택 / 힙
>
> 메소드 : 바이트 코드, 전역 변수, static 변수
>
> 스택 : 매개 변수, 지역 변수 (사용 끝나면 바로 소멸, 컴파일 시에 메모리 할당)
>
> 힙 : new로 생성된 객체(c에서는 malloc()). 호출이 끝나도 사라지지 않고 프로그램 실행 시 동적 할당

<br>

#### 오버로딩과 오버라이딩 차이는?

> 오버로딩 : 메소드의 이름은 같고, 매개변수를 다르게 함으로써 여러 메소드를 만드는 것
>
> 오버라이딩 : 부모클래스로부터 상속받은 메소드를 재정의하는 것. 자식 객체에서 오버라이딩한 메소드는 호출시 오버라이딩한 메소드가 우선시 되어 호출됨 (동일한 리턴타입, 메소드 이름, 매개변수를 가져야함)

<br>

#### 추상클래스와 인터페이스 차이는?

> 추상클래스 : 클래스 내에 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우. extends를 통해 기능을 이용하고 확장하도록 하는 클래스
>
> 인터페이스 : 모든 메소드가 추상 메소드인 경우 (여러 implements가 가능해 다중 상속 구현 가능)  뼈대만 있으며, 구현하는 모든 클래스에 대해 강제적으로 메소드를 구현하도록 만듬

<br>

#### 제네릭이란?

> 클래스에서 사용할 타입을 클래스 외부에서 설정하도록 만드는 것
>
> 제네릭으로 선언한 클래스는, 내가 원하는 타입으로 만들어 사용이 가능함
>
> <>안에는 참조자료형(클래스, 인터페이스, 배열)만 가능함
>
> (기본자료형을 이용하기 위해선 wrapper 클래스를 활용해야 함)

<br>

#### 접근 지정자 4가지

> public : 모든 접근 허용
>
> protected : 상속받은 클래스 or 같은 패키지만 접근 허용
>
> default : 기본 제한자. 자신 클래스 내부 or 같은 패키지만 접근 허용
>
> private : 외부 접근 불가능. 같은 클래스 내에서만 가능

<br>

#### Call by Value vs Call by Reference

> 값에 의한 호출 : 값을 복사해서 새로운 함수로 넘기는 호출 방식. 원본 값 변경X
>
> 참조에 의한 호출 :  주소 값을 인자로 전달하는 호출 방식. 원본 값 변경O

<br>

#### 배열과 연결리스트 차이는?

> 배열은 인덱스를 가짐. 원하는 데이터를 한번에 접근하기 때문에 접근 속도 빠름.
>
> 크기 변경이 불가능하며, 데이터 삽입 및 삭제 시 그 위치의 다음 위치부터 모든 데이터 위치를 변경해야 되는 단점 존재
>
> 연결리스트는 인덱스 대신에 현재 위치의 이전/다음 위치를 기억함.
>
> 크기는 가변적. 인덱스 접근이 아니기 때문에 연결되어 있는 링크를 쭉 따라가야 접근이 가능함. (따라서 배열보다 속도 느림)
>
> 데이터 삽입 및 삭제는 논리적 주소만 바꿔주면 되기 때문에 매우 용이함
>
> - 데이터의 양이 많고 삽입/삭제가 없음. 데이터 검색을 많이 해야할 때 → Array
> - 데이터의 양이 적고 삽입/삭제 빈번함 → LinkedList

<br>

#### Hash란?

> 데이터 삽입 및 삭제 시, 기존 데이터를 밀어내거나 채우지 않고 데이터와 연관된 고유한 숫자를 생성해 인덱스로 사용하는 방법
>
> 검색 속도가 매우 빠르다

<br>

#### Java 컴파일 과정

> 컴파일러가 소스코드를 자바 바이트 코드(.class)로 변환
>
> JVM이 바이트코드를 기계어로 변환하고, 인터프리터 방식으로 애플리케이션 실행

<br>

#### C++ 실행 과정

> 전처리 : #define, #include 지시자 해석
>
> 컴파일 : 고급 언어 소스 프로그램 입력 받고, 어셈블리 파일 만듬
>
> 어셈블 : 어셈블리 파일을 오브젝트 파일로 만듬
>
> 링크 : 오브젝트 파일을 엮어 실행파일을 만들고 라이브러리 함수 연결
>
> 실행

<br>

#### 메모리, 성능을 개선하기 위해 생각나는 방법은?

> static을 사용해 선언한다.
>
> 인스턴스 변수에 접근할 일이 없으면, static 메소드를 선언하여 호출하자
>
> 모든 객체가 서로 공유할 수 있기 때문에 메모리가 절약되고 연속적으로 그 값의 흐름을 이어갈 수 있는 장점이 존재

<br>

#### 클래스와 구조체의 차이는?

> 구조체는 하나의 구조로 묶일 수 있는 변수들의 집합이다.
>
> 클래스는 변수뿐만 아니라, 메소드도 포함시킬 수 있음
>
> (물론 함수 포인터를 이용해 구조체도 클래스처럼 만들어 낼 수도 있다.)

<br>

#### 스레드는 어떤 방식으로 생성하나요? 장단점도 말해주세요

> 생성방법 : Runnable(인터페이스)로 선언되어 있는 클래스 or Thread 클래스를 상속받아서 run() 메소드를 구현해주면 됨
>
> 장점 : 빠른 프로세스 생성, 메모리를 적게 사용 가능, 정보 공유가 쉬움
>
> 단점 : 데드락에 빠질 위험이 존재

<br>

#### 포인터를 이해하기 쉽도록 설명해주세요

> 포인터는 메모리 주소를 저장하는 변수임
>
> 주소를 지칭하고 있는 곳인데, 예를 들면 엘리베이터에서 포인터는 해당 층을 표시하는 버튼이라고 할 수 있음. 10층을 누르면 10층으로 이동하듯, 해당 위치를 가리키고 있는 변수!
>
> 포인터를 사용할 때 주의할 점은, 어떤 주소를 가리키고 있어야만 사용이 가능함



<br>

<br>

<br>

### 운영체제

---

#### 프로세스와 스레드 차이

> 프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다.
>
> 프로세스마다 최소 하나의 스레드를 보유하고 있으며, 각각 별도의 주소공간을 독립적으로 할당받는다. (code, data, heap, stack)
>
> 스레드는 이중에 stack만 따로 할당받고 나머지 영역은 스레드끼리 서로 공유한다.
>
> ##### 요약
>
> **프로세스** :  자신만의 고유 공간과 자원을 할당받아 사용
>
> **스레드** : 다른 스레드와 공간과 자원을 공유하면서 사용

<br>

#### 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?

> 프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능함
>
> 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소함
>
> 대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제 해결을 위해 '동기화'에 신경써야 한다.

<br>

#### 교착상태(DeadLock)가 무엇이며, 4가지 조건은?

> 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말한다.
>
> 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생하는 문제임
>
> 교착상태의 4가지 조건은 아래와 같다.
>
> - 상호배제 : 프로세스들이 필요로 하는 자원에 대해 배타적 통제권을 요구함
> - 점유대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원 기다림
> - 비선점 : 프로세스가 어떤 자원의 사용을 끝날 때까지 그 자원을 뺏을 수 없음
> - 순환대기 : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있음
>
> 이 4가지 조건 중 하나라도 만족하지 않으면 교착상태는 발생하지 않음
>
> (순환대기는 점유대기와 비선점을 모두 만족해야만 성립합. 따라서 4가지가 서로 독립적이진 않음)

<br>

#### 교착상태 해결 방법 4가지

> - 예방
> - 회피
> - 무시
> - 발견

<br>

#### 메모리 계층 (상-하층 순)

> |  레지스터  |
> | :--------: |
> |    캐시    |
> |   메모리   |
> | 하드디스크 |

<br>

#### 메모리 할당 알고리즘 First fit, Next fit, Best fit 결과

> - First fit : 메모리의 처음부터 검사해서 크기가 충분한 첫번째 메모리에 할당
> - Next fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾음
> - Best fit : 모든 메모리 공간을 검사해서 내부 단편화를 최소화하는 공간에 할당

<br>

#### 페이지 교체 알고리즘에 따른 페이지 폴트 방식

> OPT : 최적 교체. 앞으로 가장 오랫동안 사용하지 않을 페이지 교체 (실현 가능성 희박)
>
> FIFO : 메모리가 할당된 순서대로 페이지를 교체
>
> LRU : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체
>
> LFU : 사용 빈도가 가장 적은 페이지를 교체
>
> NUR : 최근에 사용하지 않은 페이지를 교체

<br>

#### 외부 단편화와 내부 단편화란?

> 외부 단편화 : 작업보다 많은 공간이 있더라도 실제로 그 작업을 받아들일 수 없는 경우 (메모리 배치에 따라 발생하는 문제)
>
> 내부 단편화 : 작업에 필요한 공간보다 많은 공간을 할당받음으로써 발생하는 내부의 사용 불가능한 공간

<br>

#### 가상 메모리란?

> 메모리에 로드된, 실행중인 프로세스가 메모리가 아닌 가상의 공간을 참조해 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수 있게 해주는 기법

<br>

#### 페이징과 세그먼테이션이란?

> ##### 페이징 
>
> 페이지 단위의 논리-물리 주소 관리 기법. 
> 논리 주소 공간이 하나의 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 기법
> 논리 주소 공간과 물리 주소 공간을 분리해야함(주소의 동적 재배치 허용), 변환을 위한 MMU 필요
>
> 특징 : 외부 단편화를 없앨 수 있음. 페이지가 클수록 내부 단편화도 커짐
>
> ##### 세그먼테이션
>
> 사용자/프로그래머 관점의 메모리 관리 기법. 페이징 기법은 같은 크기의 페이지를 갖는 것 과는 다르게 논리적 단위(세그먼트)로 나누므로 미리 분할하는 것이 아니고 메모리 사용할 시점에 할당됨

<br>

#### 뮤텍스, 세마포어가 뭔지, 차이점은?

> ##### 세마포어
>
> 운영체제에서 공유 자원에 대한 접속을 제어하기 위해 사용되는 신호
> 공유자원에 접근할 수 있는 최대 허용치만큼만 동시에 사용자 접근 가능
> 스레드들은 리소스 접근 요청을 할 수 있고, 세마포어는 카운트가 하나씩 줄어들게 되며 리소스가 모두 사용중인 경우(카운트=0) 다음 작업은 대기를 하게 된다
>
> ##### 뮤텍스
>
> 상호배제, 제어되는 섹션에 하나의 스레드만 허용하기 때문에, 해당 섹션에 접근하려는 다른 스레드들을 강제적으로 막음으로써 첫번재 스레드가 해당 섹션을 빠져나올 때까지 기다리는 것
> (대기열(큐) 구조라고 생각하면 됨)
>
> ##### 차이점
>
> - 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없음
> - 세마포어는 소유 불가능하지만, 뮤택스는 소유가 가능함
> - 동기화의 개수가 다름

<br>

#### Context Switching이란?

> 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업
>
> 한 프로세스의 문맥은 그 프로세스의 PCB에 기록됨

<br>

#### 사용자 수준 스레드 vs 커널 수준 스레드 차이는?

> ##### 사용자 수준 스레드
>
> 장점 : context switching이 없어서 커널 스레드보다 오버헤드가 적음 (스레드 전환 시 커널 스케줄러 호출할 필요가 없기 때문)
>
> 단점 : 프로세스 내의 한 스레드가 커널로 진입하는 순간, 나머지 스레드들도 전부 정지됨 (커널이 스레드의 존재를 알지 못하기 때문에)
>
> ##### 커널 수준 스레드
>
> 장점 : 사용자 수준 스레드보다 효율적임. 커널 스레드를 쓰면 멀티프로세서를 활용할 수 있기 때문이다. 사용자 스레드는 CPU가 아무리 많아도 커널 모드의 스케줄이 되지 않으므로, 각 CPU에 효율적으로 스레드 배당할 수가 없음
>
> 단점 : context switching이 발생함. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 많이 돌아다닐 수록 성능이 떨어지게 된다.

<br>

#### 가상메모리란?

> 프로세스에서 사용하는 메모리 주소와 실제 물리적 메모리 주소는 다를 수 있음
>
> 따라서 메모리 = 실제 + 가상 메모리라고 생각하면 안됨
>
> 메모리가 부족해서 가상메모리를 사용하는 건 맞지만, 가상메모리를 쓴다고 실제 메모리처럼 사용하는 것은 아님
>
> 실제 메모리 안에 공간이 부족하면, **현재 사용하고 있지 않은 데이터를 빼내어 가상 메모리에 저장해두고, 실제 메모리에선 처리만 하게 하는 것이 가상 메모리의 역할**이다.
>
> 즉, 실제 메모리에 놀고 있는 공간이 없게 계속 일을 시키는 것. 이를 도와주는 것이 '가상 메모리'

<br>

#### fork()와 vfork()의 차이점은?

> fork()는 부모 프로세스의 메모리를 복사해서 사용
>
> vfork()는 부모 프로세스와의 메모리를 공유함. 복사하지 않기 때문에 fork()보다 생성 속도 빠름. 
> 하지만 자원을 공유하기 때문에 자원에 대한 race condition이 발생하지 않도록 하기 위해 부모 프로세스는 자식 프로세스가 exit하거나 execute가 호출되기 전까지 block된다

<br>

#### Race Condition이란?

> 두 개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓸 때, 공용 데이터에 대한 접근이 순서에 따라 실행 결과가 달라지는 상황
>
> Race Condition이 발생하게 되면, 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없음. 따라서 이러한 상황은 피해야 하며 상호배제나 임계구역으로 해결이 가능하다.

<br>

#### 리눅스에서 시스템 콜과 서브루틴의 차이는?

> 우선 커널을 확인하자
>
> <img src="https://s24255.pcdn.co/wp-content/uploads/2012/07/Kernel.png">
>
> 커널은 하드웨어를 둘러싸고 있음
>
> 즉, 커널은 하드웨어를 제어하기 위한 일종의 API와 같음
>
> 서브루틴(SubRoutine)은 우리가 프로그래밍할 때 사용하는 대부분의 API를 얘기하는 것
>
> ```
> stdio.h에 있는 printf나 scanf
> string.h에 있는 strcmp나 strcpy
> ```
>
> ##### 서브루틴과 시스템 콜의 차이는?
>
> 서브루틴이 시스템 콜을 호출하고, 시스템 콜이 수행한 결과를 서브루틴에 보냄
>
> 시스템 콜 호출 시, 커널이 호출되고 커널이 수행한 임의의 결과 데이터를 다시 시스템 콜로 보냄
>
> 즉, 진행 방식은 아래와 같다.
>
> ```
> 서브루틴이 시스템 콜 호출 → 시스템 콜은 커널 호출 → 커널은 자신의 역할을 수행하고 (하드웨어를 제어함) 나온 결과 데이터를 시스템 콜에게 보냄 → 시스템 콜이 다시 서브루틴에게 보냄
> ```
>
> 실무로 사용할 때 둘의 큰 차이는 없음(api를 호출해서 사용하는 것은 동일)

<br>

<br>

<br>

### 데이터베이스

------

#### 오라클 시퀀스(Oracle Sequence)

> UNIQUE한 값을 생성해주는 오라클 객체
>
> 시퀀스를 생성하면 PK와 같이 순차적으로 증가하는 컬럼을 자동 생성할수 있다.
>
> ```
> CREATE SEQUENCE 시퀀스이름
> 	START WITH n
> 	INCREMENT BY n ...
> ```

<br>

#### DBMS란?

> 데이터베이스 관리 시스템
>
> 다수의 사용자가 데이터베이스 내의 데이터를 접근할 수 있도록 설계된 시스템

<br>

#### UML이란?

> 프로그램 설계를 표현하기 위해 사용하는 그림으로 된 표기법
>
> 이해하기 힘든 복잡한 시스템을 의사소통하기 위해 만듬

<br>

#### DB에서 View는 무엇인가? 가상 테이블이란?

> 허용된 데이터를 제한적으로 보여주기 위한 것
>
> 하나 이상의 테이블에서 유도된 가상 테이블이다.
>
> - 사용자가 view에 접근했을 때 해당하는 데이터를 원본에서 가져온다.
>
> view에 나타나지 않은 데이터를 간편히 보호할 수 있는 장점 존재 

<br>

#### 정규화란?

> 중복을 최대한 줄여 데이터를 구조화하고, 불필요한 데이터를 제거해 데이터를 논리적으로 저장하는 것
>
> 이상현상이 일어나지 않도록 정규화 시킨다!

<br>

#### 이상현상이란?

> 릴레이션에서 일부 속성들의 종속으로 인해 데이터 중복이 발생하는 것 (insert, update, delete)

<br>

#### 데이터베이스를 설계할 때 가장 중요한 것이 무엇이라고 생각하나요?

> 무결성을 보장해야 합니다.
>
> ##### 무결성 보장 방법은?
>
> 데이터를 조작하는 프로그램 내에서 데이터 생성, 수정, 삭제 시 무결성 조건을 검증한다.
>
> 트리거 이벤트 시 저장 SQL을 실행하고 무결성 조건을 실행한다.
>
> DB제약조건 기능을 선언한다.

<br>

#### 데이터베이스 무결성이란?

> 테이블에 있는 모든 행들이 유일한 식별자를 가질 것을 요구함 (같은 값 X)
>
> 외래키 값은 NULL이거나 참조 테이블의 PK값이어야 함
>
> 한 컬럼에 대해 NULL 허용 여부와 자료형, 규칙으로 타당한 데이터 값 지정

<br>

#### 트리거란?

> 자동으로 실행되도록 정의된 저장 프로시저
>
> (insert, update, delete문에 대한 응답을 자동으로 호출한다.)
>
> ##### 사용하는 이유는?
>
> 업무 규칙 보장, 업무 처리 자동화, 데이터 무결성 강화

<br>

#### 오라클과 MySQL의 차이는?

> 일단 Oracle이 MySQL보다 훨~씬 좋음
>
> 오라클 : 대규모 트랜잭션 로드를 처리하고, 성능 최적화를 위해 여러 서버에 대용량 DB를 분산함
>
> MySQL : 단일 데이터베이스로 제한되어있고, 대용량 데이터베이스로는 부적합. 작은 프로젝트에서 적용시키기 용이하며 이전 상태를 복원하는데 commit과 rollback만 존재

<br>

#### Commit과 Rollback이란?

> Commit : 하나의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산
>
> Rollback : 하나의 트랜잭션 처리가 비정상적으로 종료되어 DB의 일관성을 깨뜨렸을 때, 모든 연산을 취소시키는 연산

<br>

#### JDBC와 ODBC의 차이는?

> - JDBC
>   자바에서 DB에 접근하여 데이터를 조회, 삽입, 수정, 삭제 가능
>   DBMS 종류에 따라 맞는 jdbc를 설치해야함
> - ODBC
>   응용 프로그램에서 DB 접근을 위한 표준 개방형 응용 프로그램 인터페이스
>   MS사에서 만들었으며, Excel/Text 등 여러 종류의 데이터에 접근할 수 있음

<br>

<br>

## 네트워크

<br>

#### OSI 7계층을 설명하시오

> OSI 7계층이란, 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약
>
> **물리** : 전송하는데 필요한 기능을 제공 ( 통신 케이블, 허브 )
>
> **데이터링크** : 송/수신 확인. MAC 주소를 가지고 통신함 ( 브릿지, 스위치 )
>
> **네트워크** : 패킷을 네트워크 간의 IP를 통해 데이터 전달 ( 라우팅 )
>
> **전송** : 두 host 시스템으로부터 발생하는 데이터 흐름 제공
>
> **세션** : 통신 시스템 사용자간의 연결을 유지 및 설정함
>
> **표현** : 세션 계층 간의 주고받는 인터페이스를 일관성있게 제공
>
> **응용** : 사용자가 네트워크에 접근할 수 있도록 서비스 제공

<br>

#### TCP/IP 프로토콜을 스택 4계층으로 짓고 설명하시오

> - ##### LINK 계층
>
>   > 물리적인 영역의 표준화에 대한 결과
>   >
>   > 가장 기본이 되는 영역으로 LAN, WAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역이다
>
> - ##### IP 계층
>
>   > 경로 검색을 해주는 계층임
>   >
>   > IP 자체는 비연결지향적이며, 신뢰할 수 없는 프로토콜이다
>   >
>   > 데이터를 전송할 때마다 거쳐야할 경로를 선택해주지만, 경로가 일정하지 않음. 또한 데이터 전송 중에 경로상 문제가 발생할 때 데이터가 손실되거나 오류가 발생하는 문제가 발생할 수 있음. 따라서 IP 계층은 오류 발생에 대한 대비가 되어있지 않은 프로토콜임
>
> - ##### TCP/UDP (전송) 계층
>
>   > 데이터의 실제 송수신을 담당함
>   >
>   > UDP는 TCP에 비해 상대적으로 간단하고, TCP는 신뢰성잇는 데이터 전송을 담당함
>   >
>   > TCP는 데이터 전송 시, IP 프로토콜이 기반임 (IP는 문제 해결에 문제가 있는데 TCP가 신뢰라고?) 
>   >
>   > → IP의 문제를 해결해주는 것이 TCP인 것. 데이터의 순서가 올바르게 전송 갔는지 확인해주며 대화를 주고받는 방식임. 이처럼 확인 절차를 걸치며 신뢰성 없는 IP에 신뢰성을 부여한 프로토콜이 TCP이다
>
> - ##### 애플리케이션 계층
>
>   > 서버와 클라이언트를 만드는 과정에서 프로그램 성격에 따라 데이터 송수신에 대한 약속들이 정해지는데, 이것이 바로 애플리케이션 계층이다

<br>

#### TCP란?

> 서버와 클라이언트의 함수 호출 순서가 중요하다
>
> **서버** : socket() 생성 → bind() 소켓 주소할당 → listen() 연결요청 대기상태 → accept() 연결허용 → read/write() 데이터 송수신 → close() 연결종료
>
> **클라이언트** : socket() 생성 → connect() 연결요청 → read/write() 데이터 송수신 → close() 연결종료
>
> ##### 둘의 차이는?
>
> 클라이언트 소켓을 생성한 후, 서버로 연결을 요청하는 과정에서 차이가 존재한다.
>
> 서버는 listen() 호출 이후부터 연결요청 대기 큐를 만들어 놓고, 그 이후에 클라이언트가 연결 요청을 할 수 있다. 이때 서버가 바로 accept()를 호출할 수 있는데, 연결되기 전까지 호출된 위치에서 블로킹 상태에 놓이게 된다.
>
> 이처럼 연결지향적인 TCP는 신뢰성 있는 데이터 전송이 가능함 (3-way handshaking)
>
> 흐름제어와 혼잡제어를 지원해서 데이터 순서를 보장해줌
>
> - 흐름제어 : 송신 측과 수신 측의 데이터 처리 속도 차이를 조절해주는 것
>
> - 혼잡 제어 : 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것
>
> 정확성 높은 전송을 하기 위해 속도가 느린 단점이 있고, 주로 웹 HTTP 통신, 이메일, 파일 전송에 사용됨

<br>

#### 3-way handshaking이란?

> TCP 소켓은 연결 설정과정 중에 총 3번의 대화를 주고 받는다.
>
> (SYN : 연결 요청 플래그 / ACK : 응답)
>
> - 클라이언트는 서버에 접속 요청하는 SYN(M) 패킷을 보냄
> - 서버는 클라이언트 요청인 SYN(M)을 받고, 클라이언트에게 요청을 수락한다는 ACK(M+1)와 SYN(N)이 설정된 패킷을 발송함
> - 클라이언트는 서버의 수락 응답인 ACK(M+1)와 SYN(N) 패킷을 받고, ACK(N+1)를 서버로 보내면 연결이 성립됨
> - 클라이언트가 연결 종료하겠다는 FIN 플래그를 전송함
> - 서버는 클라이언트의 요청(FIN)을 받고, 알겠다는 확인 메시지로 ACK를 보냄. 그 이후 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 됨
> - 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송함
> - 클라이언트는 FIN 메시지를 확인했다는 ACK를 보냄
> - 클라이언트의 ACK 메시지를 받은 서버는 소켓 연결을 close함
> - 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해서, 일정 시간동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거침 ( TIME_WAIT )

<br>

#### UDP란?

> TCP의 대안으로, IP와 같이 쓰일 땐 UDP/IP라고도 부름
>
> TCP와 마찬가지로, 실제 데이터 단위를 받기 위해 IP를 사용함. 그러나 TCP와는 달리 메시지를 패킷으로 나누고, 반대편에서 재조립하는 등의 서비스를 제공하지 않음
> 즉, 여러 컴퓨터를 거치지 않고 데이터를 주고 받을 컴퓨터끼리 직접 연결할 때 UDP를 사용한다.
>
> UDP를 사용해 목적지(IP)로 메시지를 보낼 수 있으며, 컴퓨터를 거쳐 목적지까지 도달할 수도 있음
> (도착하지 않을 가능성도 존재함)
>
> 정보를 받는 컴퓨터는 포트를 열어두고, 패킷이 올 때까지 기다리며 데이터가 오면 모두 다 받아들인다. 패킷이 도착했을 때 출발지에 대한 정보(IP와 PORT)를 알 수 있음
>
> UDP는 이런 특성 때문에 비신뢰적이고, 안정적이지 않은 프로토콜임. 하지만 TCP보다 속도가 매우 빠르고 편해서 데이터 유실이 일어나도 큰 상관이 없는 스트리밍이나 화면 전송에 사용됨

<br>

#### HTTP와 HTTPS의 차이는?

> HTTP 동작 순서 : TCP → HTTP
>
> HTTPS 동작 순서 : TCP → SSL → HTTP
>
> SSL(Secure Socket Layer)을 쓰냐 안쓰냐의 차이다. SSL 프로토콜은 정보를 암호화시키고 이때 공개키와 개인키 두가지를 이용한다.
>
> HTTPS는 인터넷 상에서 정보를 암호화하기 위해 SSL 프로토콜을 이용해 데이터를 전송하고 있다는 것을 말한다. 즉, 문서 전송시 암호화 처리 유무에 따라 HTTP와 HTTPS로 나누어지는 것
>
> 모든 사이트가 HTTPS로 하지 않는 이유는, 암호화 과정으로 인한 속도 저하가 발생하기 때문이다.

<br>

#### GET과 POST의 차이는?

> 둘다 HTTP 프로토콜을 이용해 서버에 무언가 요청할 때 사용하는 방식이다.
>
> GET 방식은, URL을 통해 모든 파라미터를 전달하기 때문에 주소창에 전달 값이 노출됨. URL 길이가 제한이 있기 때문에 전송 데이터 양이 한정되어 있고, 형식에 맞지 않으면 인코딩해서 전달해야 함
>
> POST 방식은 HTTP BODY에 데이터를 포함해서 전달함. 웹 브라우저 사용자의 눈에는 직접적으로 파라미터가 노출되지 않고 길이 제한도 없음.
>
> 보통 GET은 가져올 때, POST는 수행하는 역할에 활용한다.
>
> GET은 SELECT 성향이 있어서 서버에서 어떤 데이터를 가져와서 보여주는 용도로 활용
>
> POST는 서버의 값이나 상태를 바꾸기 위해 활용

<br>

#### IOCP를 설명하시오

> IOCP는 어떤 I/O 핸들에 대해, 블록 되지 않게 비동기 작업을 하면서 프로그램 대기시간을 줄이는 목적으로 사용된다.
>
> 동기화 Object 세마포어의 특성과, 큐를 가진 커널 Object다. 대부분 멀티 스레드 상에서 사용되고, 큐는 자체적으로 운영하는 특징 때문에 스레드 풀링에 적합함
>
> 동기화와 동시에 큐를 통한 데이터 전달 IOCP는, 스레드 풀링을 위한 것이라고 할 수 있음
>
> ##### POOLING이란?
>
> 여러 스레드를 생성하여 대기시키고, 필요할 때 가져다가 사용한 뒤에 다시 반납하는 과정
> (스레드의 생성과 파괴는 상당히 큰 오버헤드가 존재하기 때문에 이 과정을 이용한다)
>
> IOCP의 장점은 사용자가 설정한 버퍼만 사용하기 때문에 더 효율적으로 작동시킬 수 있음.
> (기존에는 OS버퍼, 사용자 버퍼로 따로 분리해서 운영했음)
>
> 커널 레벨에서는 모든 I/O를 비동기로 처리하기 때문에 효율적인 순서에 따라 접근할 수 있음

<br>

#### 라우터와 스위치의 차이는?

> 라우터는 3계층 장비로, 수신한 패킷의 정보를 보고 경로를 설정해 패킷을 전송하는 역할을 수행하는 장비
>
> 스위치는 주로 내부 네트워크에 위치하며 MAC 주소 테이블을 이용해 해당 프레임을 전송하는 2계층 장비

<br>

<br>

## 스프링

<br>

#### Dispatcher-Servlet

>  서블릿 컨테이너에서 HTTP 프로토콜을 통해 들어오는 모든 요청을 제일 앞에서 처리해주는 프론트 컨트롤러를 말함
>
> 따라서 서버가 받기 전에, 공통처리 작업을 디스패처 서블릿이 처리해주고 적절한 세부 컨트롤러로 작업을 위임해줍니다.
>
> 디스패처 서블릿이 처리하는 url 패턴을 지정해줘야 하는데, 일반적으로는 .mvc와 같은 패턴으로 처리하라고 미리 지정해줍니다.
>
> 
> 디스패처 서블릿으로 인해 web.xml이 가진 역할이 상당히 축소되었습니다. 기존에는 모든 서블릿을 url 매핑 활용을 위해 모두 web.xml에 등록해 주었지만, 디스패처 서블릿은 그 전에 모든 요청을 핸들링해주면서 작업을 편리하게 할 수 있도록 도와줍니다. 또한 이 서블릿을 통해 MVC를 사용할 수 있기 때문에 웹 개발 시 큰 장점을 가져다 줍니다.

<br>

#### DI(Dependency Injection)

> 스프링 컨테이너가 지원하는 핵심 개념 중 하나로, 설정 파일을 통해 객체간의 의존관계를 설정하는 역할을 합니다.
>
> 각 클래스 사이에 필요로 하는 의존관계를 Bean 설정 정보 바탕으로 컨테이너가 자동으로 연결합니다.
>
> 객체는 직접 의존하고 있는 객체를 생성하거나 검색할 필요가 없으므로 코드 관리가 쉬워지는 장점이 있습니다.

<br>

#### AOP(Aspect Oriented Programming)

> 공통의 관심 사항을 적용해서 발생하는 의존 관계의 복잡성과 코드 중복을 해소해줍니다.
>
> 각 클래스에서 공통 관심 사항을 구현한 모듈에 대한 의존관계를 갖기 보단, Aspect를 이용해 핵심 로직을 구현한 각 클래스에 공통 기능을 적용합니다.
>
> 간단한 설정만으로도 공통 기능을 여러 클래스에 적용할 수 있는 장점이 있으며 핵심 로직 코드를 수정하지 않고도 웹 애플리케이션의 보안, 로깅, 트랜잭션과 같은 공통 관심 사항을 AOP를 이용해 간단하게 적용할 수 있습니다.

<br>

#### AOP 용어

> Advice : 언제 공통 관심기능을 핵심 로직에 적용할지 정의
>
> Joinpoint : Advice를 적용이 가능한 지점을 의미 (before, after 등등)
>
> Pointcut : Joinpoint의 부분집합으로, 실제로 Advice가 적용되는 Joinpoint를 나타냄
>
> Weaving : Advice를 핵심 로직코드에 적용하는 것
>
> Aspect : 여러 객체에 공통으로 적용되는 공통 관심 사항을 말함. 트랜잭션이나 보안 등이 Aspect의 좋은 예

<br>

#### DAO(Data Access Object)

> DB에 데이터를 조회하거나 조작하는 기능들을 전담합니다.
>
> Mybatis를 이용할 때는, mapper.xml에 쿼리문을 작성하고 이를 mapper 클래스에서 받아와 DAO에게 넘겨주는 식으로 구현합니다.

<br>

#### Annotation

> 소스코드에 @어노테이션의 형태로 표현하며 클래스, 필드, 메소드의 선언부에 적용할 수 있는 특정기능이 부여된 표현법을 말합니다.
>
> 애플리케이션 규모가 커질수록, xml 환경설정이 매우 복잡해지는데 이러한 어려움을 개선시키기 위해 자바 파일에 어노테이션을 적용해서 개발자가 설정 파일 작업을 할 때 발생시키는 오류를 최소화해주는 역할을 합니다.
>
> 어노테이션 사용으로 소스 코드에 메타데이터를 보관할 수 있고, 컴파일 타임의 체크뿐 아니라 어노테이션 API를 사용해 코드 가독성도 높여줍니다.

- @Controller : dispatcher-servlet.xml에서 bean 태그로 정의하는 것과 같음.
- @RequestMapping : 특정 메소드에서 요청되는 URL과 매칭시키는 어노테이션
- @Autowired : 자동으로 의존성 주입하기 위한 어노테이션
- @Service : 비즈니스 로직 처리하는 서비스 클래스에 등록
- @Repository : DAO에 등록

<br>

#### Spring JDBC

> 데이터베이스 테이블과, 자바 객체 사이의 단순한 매핑을 간단한 설정을 통해 처리하는 것
>
> 기존의 JDBC에서는 구현하고 싶은 로직마다 필요한 SQL문이 모두 달랐고, 이에 필요한 Connection, PrepareStatement, ResultSet 등을 생성하고 Exception 처리도 모두 해야하는 번거러움이 존재했습니다.
>
> Spring에서는 JDBC와 ORM 프레임워크를 직접 지원하기 때문에 따로 작성하지 않아도 모두 다 처리해주는 장점이 있습니다.

<br>

#### MyBatis

> 객체, 데이터베이스, Mapper 자체를 독립적으로 작성하고, DTO에 해당하는 부분과 SQL 실행결과를 매핑해서 사용할 수 있도록 지원함
>
> 기존에는 DAO에 모두 SQL문이 자바 소스상에 위치했으나, MyBatis를 통해 SQL은 XML 설정 파일로 관리합니다.
>
> 설정파일로 분리하면, 수정할 때 설정파일만 건드리면 되므로 유지보수에 매우 좋습니다. 또한 매개변수나 리턴 타입으로 매핑되는 모든 DTO에 관련된 부분도 모두 설정파일에서 작업할 수 있는 장점이 있습니다.

<br>

<br>

<br>